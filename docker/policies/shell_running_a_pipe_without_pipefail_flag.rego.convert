package $namespace.$type.$policyid

__rego_metadata__ := {
    "id": "XYZ-1234",
    "title": "My rule",
    "version": "v1.0.0",
    "severity": "HIGH",
    "type": "Some security check",
}

deny[res] {
    	commands := input.document[i].command[name]
	runCmd := commands[j]
	isRunCmd(runCmd)

	value := runCmd.Value
	count(value) == 1 #command is in a single string

	cmd := value[0]

	shells := ["zsh", "bash", "ash", "/bin/zsh", "/bin/bash", "/bin/ash"]

	searchIndex := indexof(cmd, shells[shell])

	searchIndex != -1

	hasPipe(substring(cmd, searchIndex, count(cmd) - searchIndex))

	not hasPipefail(commands, shells[shell], j)

	commands := input.document[i].command[name]
	runCmd := commands[j]
	isRunCmd(runCmd)

	value := runCmd.Value
	count(value) > 1 #command is in several tokens

	shellIdx := getShellIdx(value)
	shellIdx != -1
	hasPipeInArray(value, shellIdx)

	not hasPipefail(commands, value[shellIdx], j)

	cmdFormatted := replace(runCmd.Original, "\"", "'")

    res := {
        "msg": "decision message",
        "id": __rego_metadata__.id,
        "title": __rego_metadata__.title,
        "severity": __rego_metadata__.severity,
        "type": __rego_metadata__.type,
    }
}


isRunCmd(com) {
	com.Cmd == "run"
} else = false {
	true
}
hasPipe(cmd) {
	splitStr := split(cmd, " ")
	some i
	splitStr[i] == "|"
	not findTermOpBeforeIdx(splitStr, i)
} else = false {
	true
}
findTermOpBeforeIdx(tokens, maxIdx) {
	termOps := ["&&", "||", "&", ";"]
	some i
	tokens[i] == termOps[_]
	i < maxIdx
} else = false {
	true
}
getShellIdx(value) = idx {
	shells := ["zsh", "bash", "ash", "/bin/zsh", "/bin/bash", "/bin/ash"]
	some i
	value[i] == shells[_]
	idx := i
} else = -1 {
	true
}
hasPipeInArray(arr, initCmdIdx) {
	some i
	i > initCmdIdx
	arr[i] == "|"
	not findTermOpBetweenIdxs(arr, initCmdIdx, i)
} else = false {
	true
}
findTermOpBetweenIdxs(arr, startIdx, endIdx) {
	termOps := ["&&", "||", "&", ";"]
	some i
	arr[i] == termOps[_]
	i > startIdx
	i < endIdx
} else = false {
	true
}
hasPipefail(commands, shellName, idx) {
	some i
	shell := commands[i]
	shell.Cmd == "shell"
	tokens := shell.Value
	shellIdx := shellMatch(tokens, shellName)
	shellIdx != -1
	tokens[plus(shellIdx, 1)] == "-o"
	tokens[plus(shellIdx, 2)] == "pipefail"
	i < idx
} else = false {
	true
}
shellMatch(tokens, shellName) = shellIdx {
	contains(tokens[shellIdx], shellName)
} else = shellIdx {
	contains(shellName, tokens[shellIdx])
} else = -1 {
	true
}
# vim: ts=4:sw=4:expandtab
